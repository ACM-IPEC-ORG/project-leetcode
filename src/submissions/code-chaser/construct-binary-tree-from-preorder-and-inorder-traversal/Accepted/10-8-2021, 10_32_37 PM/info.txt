{"id":567926504,"lang":"cpp","time":"11 months, 4 weeks","timestamp":1633712557,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/567926504/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"25.5 MB","code":"class Solution\n{\npublic:\n    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder)\n    {\n        TreeNode *root = NULL;\n        int n = inorder.size();\n        set<TreeNode *> s;\n        stack<TreeNode *> st;\n        for (int pre = 0, in = 0; pre < n;)\n        {\n            TreeNode *node = NULL;\n            do\n            {\n                node = new TreeNode(preorder[pre]);\n                if (root == NULL)\n                {\n                    root = node;\n                }\n                if (st.size() > 0)\n                {\n                    if (s.find(st.top()) != s.end())\n                    {\n                        s.erase(st.top());\n                        st.top()->right = node;\n                        st.pop();\n                    }\n                    else\n                    {\n                        st.top()->left = node;\n                    }\n                }\n                st.push(node);\n            } while (preorder[pre++] != inorder[in] && pre < n);\n\n            node = NULL;\n            while (st.size() > 0 && in < n &&\n                   st.top()->val == inorder[in])\n            {\n                node = st.top();\n                st.pop();\n                in++;\n            }\n\n            if (node != NULL)\n            {\n                s.insert(node);\n                st.push(node);\n            }\n        }\n        return root;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}